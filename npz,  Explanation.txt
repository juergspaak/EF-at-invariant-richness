This document expains the npz files, what they have stored.

"npz, species_coex"
Contains 10^6 communities for the all coexist part. Communities were generated with rand_par_coex. paras contain the different values in one array each, para contain the parameters grouped by community. 

"npz, save_all repl"
Contains the delta_EF and species for the replacing case. p varies from 5% to 95% as well as a 100 %
para and paras the same as in species_coex. keys are a list of keys that can be useful together

"npz, adapted mue-mu"
Contains randomly generated communities of all coex. communities, in which ave is allowed up to max_ave>0.5. This is made, susch that the average reduction of growth rates is similar to the case p = 0.50. "paras", "para", "delta_EF" is similar to the other npz files. "comp" contains the rules to generate av(mu*e)/av(mu). 

Programms used:
###########################
# -*- coding: utf-8 -*-
"""
Created on Fri Jan  6 09:03:21 2017

@author: Jurg
Contains all functions that are needed to randomly generate a community
and calculate its deltaEF
"""

import numpy as np
import numpy.random as rand

sqrt = np.sqrt(3)
n = 20

def rand_par_repl(count=False):
    """ returns randomized parameters for one ecosystem
    av means average, t_ means stdv/average,
    t values are always between -1/sqrt(3), 1/sqrt(3)
    to understand the equations consult supplement data, appendix G, folder results"""
    
    rands = np.random.rand(6)
    t_fc = 2*rands[0]/sqrt-1/sqrt # t of per capita contribution, in [-1/sqrt(3),1/sqrt(3)]
    t_fr = 2*rands[1]/sqrt-1/sqrt 
    t_fs = 2*rands[2]/sqrt-1/sqrt 
    avfc = rands[3]+0.5             # average of per capita contribution
    avfr = rands[4]+0.5
    avfs = rands[5]+0.5
    
    counter1,counter2=0,0
    avec = rand.uniform(0,0.5)
    alpha = rand.uniform(-0.95,-0.05) # interaction coecfficient
    comp = -alpha*n/(1-alpha*(n-1)) #effective competition , computed
    p = int(rand.uniform(0,n-1)+1)/n
    p = 0.95
    q = 1-p
    
    parameters = 0
    while not (counter1 and coex_test_repl(*parameters)):
        rands = rand.rand(13)
        avmuc = rand.rand()*10
        # chosen such that avmur,acmuc/(p*avmuc+q*avmuc)>comp
        avmur = rand.uniform(avmuc*comp*p/(1-q*comp),min(avmuc*(1-p*comp)/(q*comp),10))

        treshhold = comp*(p*avmuc+q*avmur)
        # chosen such that min mur,muc > treshhold, i.e. coexist
        t_muc = rand.uniform(-(1-treshhold/avmuc)/sqrt,(1-treshhold/avmuc)/sqrt)
        t_mur = rand.uniform(-(1-treshhold/avmur)/sqrt,(1-treshhold/avmur)/sqrt)
        # chosen such that max(mus) < treshhold, i.e. can't coexist
        
        treshhold2 = avmuc*(1-avec)*p*comp/(1-comp*q)
        safty = 0.0*(treshhold -treshhold2)/2
        avmus = rand.uniform(treshhold2+safty,treshhold-safty)
        dist = min(treshhold/avmus-1, 1-treshhold2/avmus)/sqrt
        t_mus = rand.uniform(-dist,dist)
        
        treshhold = max(1-avmuc/avmus*(1-avec)*(1-comp*p)/(q*comp),0)
        treshhold2 = min(1-avmuc/avmus*(1-avec)/(1-comp*q)*(p*comp),0.5)
        aves = rand.uniform(treshhold, treshhold2)
        # 0<ec<1
        t_ec = 2*rands[9]/sqrt*min(1,1/avec-1)- 1/sqrt*min(1,1/avec-1)
        t_es = 2*rands[10]/sqrt*min(1,1/aves-1)- 1/sqrt*min(1,1/aves-1)
        
        # reference types can't coexist            
        #aver = 1#1-treshhold*comp/avmur*rands[11]
        #t_er = 2*rands[12]/sqrt*min(1,1/aver-1)- 1/sqrt*min(1,1/aver-1)
        if counter1 >10000: # avoids infinite loops, happens about 1/150
            counter1 = 0 
            counter2 += 1
            avec = rand.uniform(0,0.5)
            alpha = rand.uniform(-0.95,-0.05) # interaction coecfficient
            comp =  -alpha*n/(1-alpha*(n-1))
            
        parameters = avmuc,t_muc, avmur, t_mur, avmus, t_mus, avec, \
              t_ec, aves,t_es,comp,t_fc,t_fr,t_fs, \
              avfc,avfr,avfs,alpha,p
        counter1+=1
        
            
    if count:
        return 10000*counter2+counter1 
    else:
        return  parameters
    
def coex_test_repl(avmuc,t_muc, avmur, t_mur, avmus, t_mus, avec, \
              t_ec, aves,t_es,comp,t_fc,t_fr,t_fs, \
              avfc,avfr,avfs,alpha,p):
    """tests if coexistence is given in stessed site"""
    # coex in reference site
    q = 1-p
    
    # coex in stressed site
    avmuc_s = avmuc*avec*(1/avec-1 - t_muc*t_ec)
    avmus_s = avmus*aves*(1/aves-1 - t_mus*t_es)
    treshhold = comp*(p*avmuc_s+q*avmus_s)
    # extrema on boundaries:
    minimalc1 = avmuc*(1+sqrt*t_muc)*avec*(1/avec-(1+sqrt*t_ec))
    minimalc2 = avmuc*(1-sqrt*t_muc)*avec*(1/avec-(1-sqrt*t_ec))
    minimals1 = avmus*(1+sqrt*t_mus)*aves*(1/aves-(1+sqrt*t_es))
    minimals2 = avmus*(1-sqrt*t_mus)*aves*(1/aves-(1-sqrt*t_es))
    """The following checks whether r species are extinct, only necessary if aver != 0
    maximalr1 = avmur*(1+sqrt*t_mur)*aver*(1/aver-(1+sqrt*t_er))
    maximalr2 = avmur*(1-sqrt*t_mur)*aver*(1/aver-(1-sqrt*t_er))
    # maxima in interior
    loc_r = 0.5*(1/t_er*(1/aver-1)-1/t_mur)
    if -1 < loc_r < 1:
        maximalr1 = max(maximalr1, 
                        avmur*(1+loc_r*sqrt*t_mur)*aver*(1/aver-(1+loc_r*sqrt*t_er)))"""
    
    minimal = min(minimalc1,minimalc2, minimals1, minimals2)
    #maximal = max(maximalr1, maximalr2)
    if minimal<treshhold:# or maximal>treshhold:
        return False
    else:
        return True

    
def EF(avmu1,avmu2,f1,f2,cov1,cov2,alpha,p, adjust):
    """ computes the EF of the given system"""
    q = 1-p
    comp = -alpha*n/(1-alpha*(n-1))
    EF1 = n*f1*avmu1/(1+alpha)*(cov1+1-comp)
    EF2 = n*f2*avmu2/(1+alpha)*(cov2+1-comp)
    return p*EF1+q*EF2+adjust*p*q*n*comp/(1+alpha)*(f1-f2)*(avmu1-avmu2)
    
def rel_delta_EF_repl(avmuc,t_muc, avmur, t_mur, avmus, t_mus, avec, \
              t_ec, aves,t_es,comp,t_fc,t_fr,t_fs, \
              avfc,avfr,avfs,alpha,p, adjust = 1):
    covc = t_muc*t_fc
    covr = t_mur*t_fr
    EF_r = EF(avmuc,avmur,avfc,avfr,covc,covr,alpha,p, adjust)
    
    avmuc_s = avmuc*avec*(1/avec-1 - t_muc*t_ec)
    avmus_s = avmus*aves*(1/aves-1 - t_mus*t_es)
    covc_s = t_fc*(t_muc*(1/avec-1)-t_ec)/(1/avec-1-t_ec*t_muc)
    covs_s = t_fs*(t_mus*(1/aves-1)-t_es)/(1/aves-1-t_es*t_mus)
    EF_s = EF(avmuc_s,avmus_s,avfc,avfs,covc_s,covs_s,alpha,p, adjust)
    if EF_r <0 or EF_s<0:
        print ("weird, EF_r or EF_s<0")

    return 100*(EF_s-EF_r)/EF_r

def rand_par_coex(count = False):
    """ returns randomized parameters for one community"""
    
    ave = rand.uniform(0,0.5) # average sensitivity, in [0.01, 0.99]
    alpha = rand.uniform(-0.95,-0.05)
    counter = 0 # counts the number of tries to find a community
    parameters = 0
    while not (counter and coex_test_coex(*parameters)):
        """to understand why these parameters are chosen in this way, 
        see appendix G in supplement data, folder results"""
        t_f = rand.uniform(-1/sqrt, 1/sqrt) # stdv/mean of per capita contribution, in [-1/sqrt(3),1/sqrt(3)]
        n = int(rand.uniform(5,21))
        comp = -alpha*n/(1-alpha*(n-1)) #effective competition , computed
        t_mu = rand.uniform(comp-1,1-comp)/sqrt
        minimum = min(1,1/ave-1)
        t_e = rand.uniform(-minimum/sqrt,minimum/sqrt)
        
        
        parameters = ave,t_e,t_mu,t_f,comp,alpha,n
        counter +=1
    if count:
        return counter, ave
    else: 
        return ave,t_e,t_mu,t_f,comp,alpha,n  #alpha and n are just passed for convenience
    
def coex_test_coex(ave,t_e,t_mu,t_f,comp,alpha,n):
    """tests if coexistence is given in stessed site
    returns True, iff coexistence is guaranteed
    min_coex tests the species with minimal mu_i (assuming t_mu>0)"""
    min_coex = (1+sqrt*t_mu)*(1/ave-1-sqrt*t_e) \
                > comp*(1/ave-1-t_mu*t_e) 
    max_coex = (1-sqrt*t_mu)*(1/ave-1+sqrt*t_e) \
                > comp*(1/ave-1-t_mu*t_e)
    return min_coex and max_coex 
    
def rel_delta_EF_coex(ave,t_e,t_mu,t_f,comp,alpha,n, adjust = True):
    """ computes \DetalEF/EF for one ecosystem
    save_2, save_3 are used for the exact value,
    save_2_, save_3_ are used assuming cov(f, mu)=0"""
    save_1 = -(1+t_mu*t_e)*ave
    save_2 = t_f*(t_mu+t_e)/(1+t_mu*t_e)-t_f*t_mu
    save_3 = t_mu*t_f+1-comp
    return 100*save_1*(1+save_2/save_3)

    
def fun_covs(para, delta_EF):
    covs = {'11':[], '1-1':[], '-11':[], '-1-1':[]}
    for i in range(len(delta_EF)):
        a = str(int(np.sign(para[i][1]*para[i][2])))
        b = str(int(np.sign(para[i][1]*para[i][3])))
        covs[a+b].append(delta_EF[i])
    covs2 = {}
    covs2[r'cov$(e,\mu) = 1$, cov$(e,f)=1$'] = covs['11']
    covs2[r'cov$(e,\mu) = -1$, cov$(e,f)=-1$'] = covs['-1-1']
    covs2[r'cov$(e,\mu) = -1$, cov$(e,f)=1$'] = covs['-11']
    covs2[r'cov$(e,\mu) = 1$, cov$(e,f)=-1$'] = covs['1-1']
    return covs2
    
##############################



# -*- coding: utf-8 -*-
"""
Created on Thu Dec 15 09:46:27 2016

@author: spaakjue
Computes the DeltaEF on random parameters, trying to average them
"""

from timeit import default_timer as timer
import numpy as np

import community_construction as community

iterations = 100
save = np.zeros(iterations)
print("estimated time" , iterations*6/1000)
start = timer()
numb_par = 19
para = np.zeros([iterations,numb_par])
for i in range(iterations):
    para[i] = community.rand_par_repl()
    save[i]=min(community.rel_delta_EF_repl(*para[i]),1)
    
end=timer()
print(end-start)

paras = numb_par*[0]
for i in range(numb_par):
    paras[i] = [para[j][i] for j in range(iterations)]
labels = [r'$\bar{\mu^c}$',r'$t_{\mu^c}$', r'$\bar{\mu^r}$',r'$t_{\mu^r}$', r'$\bar{\mu^s}$',r'$t_{\mu^s}$',\
          r'$\bar{e^c}$',r'$t_{e^c}$', r'$\bar{e^s}$',r'$t_{e^s}$',r'$C_\alpha^n$',r'$t_{f^c}$',r'$t_{f^r}$',\
          r'$t_{f^s}$',"avfc","avfr","avfs",r'$\alpha$',r'$p$'] 


####################################################

# -*- coding: utf-8 -*-
"""
Created on Thu Dec 15 09:46:27 2016

@author: spaakjue
Computes the DeltaEF on random parameters, trying to average them
The distributions try to be similar to the ones in the replacing programm
"""
import numpy as np
from timeit import default_timer as timer

import community_construction as community

counter1,counter2=0,0 #count # ecosystems with positive/negative change in EF
iterations = int(1000000)   #number of random ecosystems
rel_delta_EF = np.zeros([iterations]) #saves \DeltaEF/EF
neg_para = np.zeros([iterations,7]) # saves the parameters in negative change ecosystems
neg_delta_EF = np.zeros(iterations) # saves rel_delta_EF in cases it is negative
pos_para = np.zeros([iterations,7]) # saves the parametesr in positive change ecosystems
pos_delta_EF = np.zeros(iterations) # saves rel_delta_EF in cases it's positive
para = np.zeros([iterations,7])     # saves the parameters of all ecosystems
label_names = [r'$\bar{e}$', r'$t_e$',r'$t_{\mu}$',
                r'$t_f$', r'$C_{\alpha}^n$', r'$\alpha$', r'$n$'] # names for axes used in plit function
label_delEF = r'$\Delta EF/EF$'
sqrt = np.sqrt(3)


axis = [[0,1],[0,1/np.sqrt(3)], [-1/np.sqrt(3),1/np.sqrt(3)], [-1/np.sqrt(3),1/np.sqrt(3)], 
        [0,1], [-1,0], [4.9,20.1]] #axis for plotting heatplots 

print("estimated time: ", iterations /10000*2)
start=timer()
for i in range(iterations):
    parameters = community.rand_par_coex() # generate random community
    para[i]=parameters #save all parameters
    rel_delta_EF[i] = community.rel_delta_EF_coex(*parameters)
    if rel_delta_EF[i] < -100: #mistake happend
        print(rel_delta_EF[i], parameters)
    elif rel_delta_EF[i] < 0:
        neg_delta_EF[counter1] = rel_delta_EF[i]
        neg_para[counter1,:] = para[i,:]
        counter1+=1
    else:
        pos_delta_EF[counter2] = rel_delta_EF[i]
        pos_para[counter2,:] = para[i,:]
        counter2+=1
    
        
end=timer()
print(end-start)
neg_delta_EF = neg_delta_EF[:counter1] # chop of unimportant
neg_para = neg_para[:counter1]
pos_delta_EF = pos_delta_EF[:counter2]
pos_para = pos_para[:counter2]
paras = 7*[0]   # are used to save the parameters in one list
neg_paras = 7*[0]
pos_paras = 7*[0]
for i in range(7):
    paras[i] = [para[j][i] for j in range(iterations)]
    neg_paras[i] = [neg_para[j][i] for j in range(counter1)]
    pos_paras[i] = [pos_para[j][i] for j in range(counter2)]
                                
rel_min_comp = [1-paras[4][i] for i in range(len(paras[4]))]
pos_min_comp = [1-pos_paras[4][i] for i in range(len(pos_paras[4]))]
neg_min_comp = [1-neg_paras[4][i] for i in range(len(neg_paras[4]))]

zero_delta_EF = [min(0,i) for i in rel_delta_EF]

##########################
